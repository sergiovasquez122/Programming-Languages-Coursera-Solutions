-Racket and ML have much in common

-Key differences
--Syntax
--Pattern-matching vs. structu-test and accessor-functions

-Biggest difference: ML's type system and Racket's lack thereof

Questions to think about?
-What is type-checking? Static typing? Dynamic typing? Etc.
-Why is type-checking approximate?
-What are the advantage and disadvantages of type-checking?

ML from a Racket perspective 

-Syntax, etc, aside, ML is like a well-defined subset of Racket
-Many of the programs it disallows have bugs
(define (g x) (+ x x)) ; ok
(define (f y) (+ y (car y)))
(define (h z) (g (cons z 2)))

-In fact, in what ML allows, I never need primitives like number?

-But other programs it disallows I may actually want to write

(define (f x) (if (> x 0) true (list 1 2)))
(define xs (list 1 true "hi"))
(define y (f car xs))

Racket from an ML Perspective 

One way to describe Racket is that it has one big datatype
- All values have this type
datatype theType = Int of int 
		   | String of string
                   | Pair of theType * theType
                   | Fun of theType -> theType

-Constructors are applied implicityly 
--42 is really like Int 42

-Primitives implicitly check tags and extract data, raising errors for wrong constructors

-fun car v = case v of Pair(a, b) => a | _ => raise _
-fun pair? v = case v of Pair _ => true | _ => false

-Built-in constructors for "theType": numbers, strings, booleans, pairs, symbols, procedures, etc

-Each struct-definition creates a new constructor, dynamically adding to "theType"

What is Static Checking?

-Static checking is anything done to reject a program after it (successfully) parses but before it runs
-Part of PL's definition: what static checking is performed
--A "helpful tool" could do more checking

-Common way to define a PL's static checking is via a type system
--Approach is to give each variable, expression, etc.
--Purposes inclucde preventing misuse of primitives enforcing abstraction, and avoiding dynamic checking
---Dynamic means at run-time

-Dynamically-typed languages do (almost) no static-checking
--Line is not absolute

In ML, type-checking ensures a program (when run) will have:

- A primitive operation used on a value of the wrong type
-- Arithmetic on a non-number
-- e1 e2 where e1 does not evaluate to a function
-- A non-boolean between if and then

- A variable not defined in the environment
- A pattern-match with a redundant pattern
- Code outside a module call a function not in the module's signature

Question
Suppose we modify an ML compiler to remove the check for redundant pattern. Which of the following is true?

1. This is okay because we still the same programming language

2. We are now implementing a slightly different language becase a different set of programs is accepted by static checking.

3. Our type system is now pointless because it would be possible to pass functions expecting strings

4. Pattern matching is no longer a useful feature

2. is the correct answer. 

in ML, type-checking does not prevent any of these errors
- Instead, detected at run-time

- Calling functions such that exceptions occurs, e.g hd []
- An array-bounds error
- Division-by-zero

In general, no type system prevents logic / algoritmic errors
- Reversing the branches of a conditional 
- Calling f instead of g
(Without a program specification, type-checker can't "read minds")

Purpose of a type system is to prevent certain from occurring at run-time

Language design includes deciding what is checked and how

Static / dynamic checking are two points on a continuum

Soundness and Completeness

What does it mean for a type system to be correct

Suppose a type system to prevent X for some X

- A type system is sound if it never accepts a program that, when run with some input, does X
 
-- No false negatives 

- A type system is complete if it never rejects a program that, no matter what input it is run with, will not do X

-- No false positives

The goal is usually for a PL type system to be sound but not complete

- "Fancy features" like generics aimed at "fewer false positives"

Notice soundness/completenes is with respect to X

Question 

Suppose we have a language with arrays and a very strange-and-not-useful type system that (1) requires all arrays to have at least one element and (2) allows accessing only the first element of an array. With respecting to array-bound violations this system is:

Sound but not complete
Complete but not sound
Sound and complete
Neither sound nor complete

It is sound but not complete

Incompleteness

no examples of false negatives in ML

a few functions ML rejects even though they do not divide by a string

examples of false positives in ML

fun f1 x = 4 div "hi" (* but f1 never called *)

fun f2 x = if true then 0 else 4 div "hi"

fun f3 x = if x then 0 else 4 div "hi"

fun f4 x = if x <= abs x then 0 else 4 div "hi"

fun f5 x = 4 div x

val y = f5 (if true then 1 else "hi")

Why incompletness

- Almost anything you might like to check statically is undecidable
-- Any static checker cannot do all of: (1) always terminate (2) be sound (3) be complete
-- This is a mathematical theorem

- Examples
-- Will this function terminate on some input?
-- Will this function ever use a variable not in the environment
-- Will function trea a string as a function?
-- Will this function divide by zero?

- Undecidability is an essential concept and the core of computing
- The inherent approximation of static checking is probably its most important ramification

Question

Why will there never be a popular programming language with a sound and complete type system for preventing calling a function with the wrong number of arguments?

Because too few programmers want thsi property checked statically

Because checking this property would make compiling program takes too long

Because completeness is not a useful property for this sort of type system

Because it is impossible if we assume the type-checker must always terminate.

What about unsoundness

Suppose a type system were unsound. What could the PL do?

- Fix it with an updated language definition?
- Insert dynamic checks as needed to prevent X from happening?
- Just allow X to happen even if "tried to stop it"?

- Worse: Allow not just X, but anything to happen if "Programmer goes something wrong"
  -- Will discuss C and C++ next

Why weak typing

- Weak typing: There exists programs that, by definitoin, must pass static checking but then when run can "set the computer on fire"?
	- Dynamic checking is optional and in practice not done
	- Why might anything happen?

- Ease of language implementation: Checks left to the programmer
- Performance: Dynamic Checks take time
- Lower level: Compiler does not insert information like array sizes, so it cannot do the check

Weak typing is a poor name: Really about doing neither static nor dynamic checks
- A big problem is array bounds, which most PLs check dynamically 

What weak typing has caused

- Old now-much-rarer saying "strong types for weak minds"
-- Idea was humans will always be smarter than type system
   so need to let them say "trust me"
- Reality: humans are really bad at avoiding bugs
-- We need all the help we can get
-- And type system have gotten much more expressive

- 1 bug in a 30-million line operating system written in C can make an entire computer vulnerable

Example: Racket

- Racket is not weakly typed
-- It just checks most things dynamically
-- Dynamic checking is the definition - If the implementation can analyze teh coee to ensure some checks are not needsedd, then it cna optimize away

- Not having ML or Java's rules can be convenient
-- Cons cell can build anything
-- Anything except false is true

This is nothing like the "catch-fire semantics" of weak typing

Question 
Which of the following is true?

Every dynamically typed language is weakly typed.

Every weakly typed language is dynamically typed.

A weakly typed language might allow programs that crash but it is not allowed to let programs corrupt data on the computer's disk

Weak typing really means a type system that allows programs for which a correct language implemenation is allowed to do anything, even something totally unrelated to the code in the program

the 4th one is correct

weak typing means the implementation is allowed to do anything for some programs that type-check -- it can run illegal programs and cause anything to happen.

Another misconception

What operations are primitive defined and when an error?

- Example: is "foo" + "bar" allowed?
- Example: is "foo" + 3 allowed?
- Example: is arr[10] allowed if arr hs only 5 elements?
- Example: Can you call a function with too few or too many arguments?

This is not static vs dynamic checking
- It is what is the run-time semantics of the primitive
- It is related because it also involves trade-offs between catching bugs sooner versus maybe being more convenient 
- More like changing evalution rules of language

Racket generally less lenient on these things e.g Ruby
